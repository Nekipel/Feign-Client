Feign Client и его аналоги

 

Feign — это первый шаг в реализации архитектуры микросервиса по средствам Netflix.

В реальности слабо связанных сервисов очень важно? чтобы общение между ними было легковесным и простым для отладки. Для упрощения связи по REST мы и используем Feign: при помощи него мы будем поглощать сообщения от других сервисов и автоматически превращать их в Java объекты.

Feign — это декларативный HTTP клиент, разработанный компанией Netflix. Основным преимуществом решения является то, что разработчику необходимо только описать интерфейс, в то время как реализация будет создана во время выполнения. 

Feign использует интерфейсы, аннотированные @FeignClient, чтобы генерировать API запросы и мапить ответ на Java классы.

Он шлет http запросы другим сервисам.

Его особенность в том, что нам не нужно знать, где и на каком порту находится какой-либо сервис.

Мы просто говорим нашему «сервис-1», чтобы он через Feign клиент пошел, например, к «сервис-2» и получил у него необходимые нам данные. Далее Feign обращается к Eureka Server и спрашивает, где находится «сервис-2».

Если «сервис-2» регистрировался в Eureka Server, то Eureka будет всё знать о «сервис-2»: где он находится, на каком порту, его URL и т. д.

Тебе нужно только описать, как получить доступ к удаленной службе API, указав такие детали, как URL, тело запроса и ответа, принятые заголовки и т. д. Клиент Feign позаботится о деталях реализации.

Netflix предоставляет Feign в качестве абстракции для вызовов на основе REST, благодаря которым микросервисы могут связываться друг с другом, но разработчикам не нужно беспокоиться о внутренних деталях REST.

Рассмотрим, как работать с Feign в коде.

Предположим, у нас есть сервис А и сервис B, оба зарегистрированы в Eureka. Мы хотим из сервиса А вызвать сервис B и получить какие-то данные.

Для начала нам нужно указать аннотацию @EnableFeignClients над основным классом.

@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients
public class UserServiceApplication {

  public static void main(String[] args) {
     SpringApplication.run(UserServiceApplication.class, args);
  }

}
А теперь давайте рассмотрим небольшой пример для понимания.
Предположим, У нас есть сервис А и сервис B, которые оба зарегистрированы в Eureka. Мы хотим из сервиса А вызвать сервис B и получить какие-то данные.

Сервис B имеет следующий метод в контроллере


@RestController 
@RequestMapping("/api/books")
public class BookController {

@GetMapping
public List<Book> getAllBooks() {
   return booksRepository.findAll();
}

}

Чтобы из сервиса А вызвать сервис B мы создадим в сервисе А feign client.

@FeignClient(name = "service-b")
public interface ServiceBFeignClient {
  @GetMapping("/api/books")
  List<Book> getAllBooks();
 }
В аннотации @FeignClient мы указываем имя того сервиса, который хотим вызвать (сервис B).

Аннотация @GetMapping содержит путь, который отображается на тот же самый путь в аннотации @RequestMapping в микросервисе B и указывает, что это будет GET запрос.

Просто не правда ли? Ты можешь внедрять ServiceFeignClient как бин и пользоваться им.

Помимо этого ты можешь настроить FeignClient как угодно. В интернете можно найти множество реализаций, например, настроить кастомный ObjectMapper, для этого нужно лишь создать отдельный класс конфигурации и указать его в параметрах аннотации @FeignClient(name=”serivce-b”, configuration).

Если тебе нужно использовать внешнюю веб-службу, которая не является частью твоей архитектуры микросервисов и не зарегистрирована в твоей службе Eureka, используйте URL в качестве параметра аннотации @FeignClient.

@FeignClient(url = "https://bla-bla-bla",)
public interface ServiceBConnector {
   @GetMapping("/getAllBooks")
   List<Books> getAllBooks();


Владимир Фролов
23.11.2022 08:11
Забудьте всё что вы прочитали выше и делайте по видео
https://youtu.be/tlshVRtbS_c


простыми словами - feign client нужен что бы проще использовать в одном микросервисе другой микросервис.
Что бы посмотреть как работает код выше, создайте в сервисе А (откуда хотите вызвать сервис В) Рест контроллер, сделайте autowired интерфейса ServiceBFeignClient, далее в гетметоде верните ServiceBFeignClient.getAllBooks() 
Я в "родительском" методе getAllBooks() возвращал просто какой то стринг
что бы посмотреть как это работает, зайдите на адреса контроллеров микросервиса А и В http://localhost:ПОРТ/api/books где порт это порт, указанный в конфиг.файле yaml (также номер порта можно увидеть на хост страничке Eureka в списке работающих серверов)
